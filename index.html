<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AI Chess Puzzle Lab</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    :root { color-scheme: dark; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
      gap: 1rem;
    }
    #board { width: 480px; max-width: 100vw; }
    .panel {
      max-width: 480px;
      width: 100%;
      background: #1c1c1c;
      padding: 1rem;
      border-radius: 0.75rem;
      box-shadow: 0 0 20px rgba(0,0,0,0.4);
      position: sticky;
      top: 1rem;
    }
    .audio-panel { position: static; }
    #status, #commentary {
      min-height: 2.2em;
      overflow-wrap: anywhere;
      margin: 0.2rem 0;
    }
    #commentary { min-height: 3em; }
    button {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      border: none;
      cursor: pointer;
      margin-right: 0.5rem;
    }
    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.3rem 0.6rem;
      border-radius: 999px;
      font-size: 0.85rem;
    }
    .pill-ok { background: #19361d; color: #9ae3a0; }
    .pill-off { background: #3a1d1d; color: #f3a7a7; }
    .pill-warn { background: #3a301d; color: #f3e1a7; }
    audio { width: 100%; margin-top: 0.5rem; }
    .stack { display: flex; flex-direction: column; gap: 0.35rem; }
  </style>
</head>
<body>
  <h1>AI Chess Puzzle Lab</h1>
  <div id="board"></div>
  <div class="panel">
    <div class="controls" style="justify-content: space-between; align-items: center;">
      <div>
        <label for="puzzle-select">Puzzle:</label>
        <select id="puzzle-select"></select>
      </div>
      <div>
        <button id="prev-puzzle">Prev puzzle</button>
        <button id="next-puzzle">Next puzzle</button>
      </div>
    </div>
    <div id="puzzle-meta"></div>
    <p id="status"></p>
    <p id="commentary"></p>
    <div class="controls">
      <button id="prev-move">◀︎ Prev (←)</button>
      <button id="next-move">Next (→)</button>
      <button id="reset">Reset</button>
    </div>
  </div>
  <div class="panel audio-panel">
    <div class="controls" style="justify-content: space-between; align-items: center;">
      <strong>Commentary audio</strong>
      <span id="audio-backend" class="pill pill-warn">Checking…</span>
    </div>
    <div class="stack">
      <p id="audio-status">Enable a move to hear the narration.</p>
      <div class="controls">
        <button id="play-commentary">Play commentary</button>
        <button id="regen-commentary">Regenerate</button>
      </div>
      <audio id="commentary-audio" controls preload="none"></audio>
    </div>
  </div>

  <!-- Use a non-module UMD build of chess.js for browser globals -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <script>
    async function main() {
      const res = await fetch('puzzles.json');
      const puzzles = await res.json();
      let puzzleIndex = 0;
      let puzzle = puzzles[puzzleIndex];

      const game = new Chess(puzzle.fen);
      const board = Chessboard('board', {
        position: puzzle.fen,
        draggable: false,
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
      });
      // expose for debugging/smoke tests
      window._game = game;
      window._board = board;

      const metaEl = document.getElementById('puzzle-meta');
      const statusEl = document.getElementById('status');
      const commentaryEl = document.getElementById('commentary');
      const nextBtn = document.getElementById('next-move');
      const prevBtn = document.getElementById('prev-move');
      const resetBtn = document.getElementById('reset');
      const selectEl = document.getElementById('puzzle-select');
      const prevPuzzleBtn = document.getElementById('prev-puzzle');
      const nextPuzzleBtn = document.getElementById('next-puzzle');
      const audioEl = document.getElementById('commentary-audio');
      const audioStatusEl = document.getElementById('audio-status');
      const audioBackendEl = document.getElementById('audio-backend');
      const playAudioBtn = document.getElementById('play-commentary');
      const regenAudioBtn = document.getElementById('regen-commentary');

      // populate selector
      selectEl.innerHTML = puzzles.map((p, idx) => `<option value="${idx}">${idx + 1}. ${p.id}</option>`).join('');

      let moveIndex = 0;
      let audioBackendAvailable = false;
      let audioManifestLoaded = false;
      const audioManifest = new Map();
      const audioCache = new Map();

      function audioCacheKey(idx = moveIndex) {
        return `${puzzle.id}:${idx}`;
      }

      function currentCommentary() {
        if (moveIndex <= 0) return '';
        return (puzzle.commentary || [])[moveIndex - 1] || '';
      }

      function refreshAudioBadge() {
        if (audioBackendAvailable) {
          audioBackendEl.textContent = 'Audio: Dia backend';
          audioBackendEl.className = 'pill pill-ok';
          return;
        }
        if (audioManifestLoaded) {
          audioBackendEl.textContent = 'Audio: Dia static';
          audioBackendEl.className = 'pill pill-warn';
          return;
        }
        audioBackendEl.textContent = 'Audio offline';
        audioBackendEl.className = 'pill pill-off';
      }

      function updateAudioStatusText() {
        if (moveIndex === 0) {
          audioStatusEl.textContent = 'Play the first move to unlock audio.';
          return;
        }
        if (audioManifestLoaded) {
          audioStatusEl.textContent = 'Dia commentary ready.';
          return;
        }
        if (audioBackendAvailable) {
          audioStatusEl.textContent = 'Audio via backend ready.';
          return;
        }
        audioStatusEl.textContent = 'Audio unavailable for this move.';
      }

      function resetAudio() {
        audioEl.pause();
        audioEl.removeAttribute('src');
        audioEl.load();
        updateAudioStatusText();
        updateAudioButtons();
      }

      function updateAudioButtons() {
        const canPlayStatic = moveIndex > 0 && audioManifestLoaded;
        const canPlay = moveIndex > 0 && (canPlayStatic || audioBackendAvailable);
        playAudioBtn.disabled = !canPlay;
        regenAudioBtn.disabled = moveIndex === 0; // allow forcing backend even if health check failed
      }

      async function playCommentary({ force = false, autoplay = false } = {}) {
        if (moveIndex === 0) {
          audioStatusEl.textContent = 'Play the first move to unlock audio.';
          updateAudioButtons();
          return;
        }

        const text = currentCommentary().trim();
        if (!text) {
          audioStatusEl.textContent = 'No commentary available for this move.';
          updateAudioButtons();
          return;
        }

        if (audioManifestLoaded && !force) {
          const slug = puzzle.id.toLowerCase().replace(/[^a-z0-9_-]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') || 'puzzle';
          const fname = `audio/${slug}-m${String(moveIndex).padStart(2, '0')}.wav`;
          audioEl.src = `${fname}?t=${Date.now()}`;
          audioStatusEl.textContent = 'Playing Dia commentary (static).';
          if (autoplay) {
            audioEl.play().catch(() => {});
          }
          updateAudioButtons();
          return;
        }

        if (audioBackendAvailable) {
          const cacheKey = audioCacheKey();
          if (audioCache.has(cacheKey) && !force) {
            const cachedUrl = audioCache.get(cacheKey);
            audioEl.src = `${cachedUrl}?t=${Date.now()}`;
            audioStatusEl.textContent = 'Playing cached audio.';
            if (autoplay) {
              audioEl.play().catch(() => {});
            }
            updateAudioButtons();
            return;
          }

          audioStatusEl.textContent = 'Requesting speech...';
          playAudioBtn.disabled = regenAudioBtn.disabled = true;
          try {
            const res = await fetch('/api/tts', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text,
                puzzle_id: puzzle.id,
                move_index: moveIndex,
                move_san: puzzle.san_solution[moveIndex - 1] || '',
                force
              })
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || `TTS failed (${res.status})`);
            }
            const data = await res.json();
            if (!data.url) {
              throw new Error('TTS backend did not return audio.');
            }
            audioCache.set(cacheKey, data.url);
            audioEl.src = `${data.url}?t=${Date.now()}`;
            audioStatusEl.textContent = `Audio ready via ${data.engine || 'tts'}${data.cached ? ' (cached).' : '.'}`;
            if (autoplay) {
              audioEl.play().catch(() => {});
            }
          } catch (err) {
            console.error(err);
            audioStatusEl.textContent = `Audio error: ${err.message}`;
          } finally {
            updateAudioButtons();
          }
          return;
        }

        audioStatusEl.textContent = 'Audio unavailable for this move.';
        updateAudioButtons();
      }

      async function checkAudioBackend() {
        try {
          const res = await fetch('/health', { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json().catch(() => ({}));
          audioBackendAvailable = true;
          audioBackendEl.textContent = data.engine ? `Audio: ${data.engine}` : 'Audio ready';
          audioBackendEl.className = 'pill pill-ok';
        } catch (err) {
          audioBackendAvailable = false;
          refreshAudioBadge();
          updateAudioStatusText();
        }
        refreshAudioBadge();
        updateAudioButtons();
      }

      function updateStatus() {
        if (moveIndex === 0) {
          statusEl.textContent = 'White to move and win. Click "Play next move" to see the solution.';
          commentaryEl.textContent = '';
        } else if (moveIndex < puzzle.san_solution.length) {
          statusEl.textContent = `Played: ${puzzle.san_solution.slice(0, moveIndex).join(' ')}`;
          const comment = (puzzle.commentary || [])[moveIndex - 1];
          commentaryEl.textContent = comment ? `Commentary: ${comment}` : '';
        } else {
          statusEl.textContent = 'Line complete. Final position shown.';
          const comment = (puzzle.commentary || [])[puzzle.commentary.length - 1];
          commentaryEl.textContent = comment ? `Commentary: ${comment}` : '';
        }
        updateAudioStatusText();
        updateAudioButtons();
      }

      function loadPuzzle(idx) {
        puzzleIndex = (idx + puzzles.length) % puzzles.length;
        puzzle = puzzles[puzzleIndex];
        selectEl.value = puzzleIndex;
        game.reset();
        game.load(puzzle.fen);
        board.position(puzzle.fen);
        metaEl.innerHTML = `
          <strong>ID:</strong> ${puzzle.id}<br/>
          <strong>Source:</strong> ${puzzle.source}<br/>
          <strong>Side to move:</strong> ${puzzle.side_to_move === 'w' ? 'White' : 'Black'}<br/>
          <strong>Result:</strong> ${puzzle.result_type}<br/>
          <strong>Themes:</strong> ${puzzle.themes.join(', ')}
        `;
        moveIndex = 0;
        updateStatus();
        resetAudio();
      }

      nextBtn.addEventListener('click', () => {
        if (moveIndex >= puzzle.san_solution.length) return;
        const san = puzzle.san_solution[moveIndex];
        try {
          game.move(san);
          board.position(game.fen());
          moveIndex += 1;
          updateStatus();
          playCommentary({ autoplay: true });
        } catch (e) {
          console.error('Illegal SAN in sequence:', san, e);
          statusEl.textContent = 'Error: illegal move in solution sequence. Check console.';
        }
      });

      prevBtn.addEventListener('click', () => {
        if (moveIndex <= 0) return;
        game.undo();
        moveIndex -= 1;
        board.position(game.fen());
        updateStatus();
      });

      resetBtn.addEventListener('click', () => {
        loadPuzzle(puzzleIndex);
      });
      playAudioBtn.addEventListener('click', () => playCommentary({ autoplay: true }));
      regenAudioBtn.addEventListener('click', () => playCommentary({ force: true, autoplay: true }));

      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight') {
          nextBtn.click();
        } else if (e.key === 'ArrowLeft') {
          prevBtn.click();
        } else if (e.key === 'ArrowUp') {
          prevPuzzleBtn.click();
        } else if (e.key === 'ArrowDown') {
          nextPuzzleBtn.click();
        }
      });

      selectEl.addEventListener('change', (e) => {
        loadPuzzle(parseInt(e.target.value, 10));
      });
      prevPuzzleBtn.addEventListener('click', () => {
        loadPuzzle(puzzleIndex - 1);
      });
      nextPuzzleBtn.addEventListener('click', () => {
        loadPuzzle(puzzleIndex + 1);
      });

      async function loadAudioManifest() {
        try {
          const res = await fetch('audio_manifest.json', { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          data.forEach(entry => {
            audioManifest.set(entry.id, entry.clips || []);
          });
          audioManifestLoaded = true;
        } catch (err) {
          console.warn('Audio manifest missing or unreadable:', err);
          audioManifestLoaded = false;
        } finally {
          refreshAudioBadge();
          updateAudioButtons();
        }
      }

      loadPuzzle(0);
      await loadAudioManifest();
      await checkAudioBackend();
    }

    main().catch(err => {
      console.error(err);
      document.getElementById('status').textContent = 'Error loading puzzle.';
    });
  </script>
</body>
</html>
